Gabriela Onelli

Dr. Yang

SSW 345

2 April 2021

Homework 5: Reflection

**Design**
1. What was most helpful about thinking about design methods of your project?

I think the most helpful part of thinking about design methods, was the way a thoughtfulness about the project outside of the technical difficulties. 
Most times when focusing on a problem, I personally jump straight to the specific actions I need to take to fix the problem like if I’m told to make a website my first 
thought is usually regarding server connections, overall layout, key functionalities and most importantly how to write the code to make these things work. 
While I intuitively might do some leg work in the beginning like is there a color scheme that the client wants implemented or talking over basic user needs, 
they are usually steps I try to rush through to get to the coding aspect as fast as possible. With the design methods like using UML or talking though design patterns, 
I was forced to take this step I usually rush through and think about it more critically. Instead of jumping straight into videos on how to make chrome extensions at 
the beginning of the semester I had to answer more abstract questions. Who are the users of this system, what kind of experience or problems are they going to need this system 
to answer, how can this be laid out to work well for them. Being forced to think less on technical specifics and more on abstract levels I think was the most helpful as it
left a clear idea of what was happening and what was needed to move forward at all times. I was never confused on the directions that the program changed because of all 
the prep work done beforehand that left me with an incredibly clear understanding of project outline.

2. What was most difficult? What would you do differently?

I think the most difficult part of this was learning the language necessary to do the homeworks and progress. Maybe not the hardest thing in the world, but the overall ideas 
presented about design weren’t hard for me. They came relatively intuitively once someone pointed them out. The harder part was just learning and remembering the new language 
I was given to explain what were intuitive ideas and effectively communicate with my other group members. I think the communicating with group members was another hard task that
were helped by the design methods. A lot of projects and school work up to this point has been by myself as such being forced to ask questions and work through problems 
collaboratively by the design methods like where are we storing data were difficult and important things I needed to work through. As for what I’d do differently, 
I’m not really sure there is much I would do differently. My scores show that the projects were completed well and nothing was insurmountable, 
so I feel despite all difficulties there wasn’t anything I really regretted.

3. What design methods might you want to try again in the future on another project?

I definitely would implement wireframing again as I feel like it helps to have this visualization of what the end product should be to make it easier when focusing on 
individual tasks. It helps provide the reference image of the whole forest while each team member is focused on the individual tree they’re painting. 
I would also use the sequencing diagram again as I think it’s really useful for thinking through the logic of the code in abstract enough terms that it doesn’t overwhelm you 
from the beginning. 

**Implementation**
1. What was most helpful about implementing, testing, and integration in your bot project?

I think the most helpful aspect was the way it improved merging and avoided conflict in the code. By pulling more often to ensure the newest code was being used and committing more often than I normally would commit, it was easier to work on the code itself. I was less worried about my new features not working and having to manually resolve conflicts in the code.
 
2. What was most difficult? What would you do differently?

I think the most difficult part of this project segment was testing the bot components. Part of this came from unfamiliarity with the languages and programs, 
using Google alarms for example. When I was researching them to use for the pomodoro technique I wasn’t familiar with its code, how it would interact with other code, 
or even what the end result of the code would do. But I think the more difficult part was that I didn’t write the code that made it easy to test. 
Most of my testing involved running the code and seeing how the extension worked after the edit. Only working in messages or checks if the code failed to see what went wrong.
If I could do this over, I think I would work on making more formalized test scripts like we saw during class for our homework assignments. They may have had their flaws, 
but test scripts like those did allow me to see clearly and quickly whether my change caused what I wanted it to in the code.

3. What implementation, testing, and integration methods might you want to try again in the future on another project?

I think I would want to try writing more sophisticated testing methods and developing them earlier than I did. I still have the habit of creating tests after the fact rather than before hand and not giving them a fair amount of attention. In the future I would like to change that habit so I better and more efficient methods for testing.


**Process**
1. What was most helpful about implementing kanban and code review in your project?

For code review I think the most helpful part of that was just reinforcing the idea that having another set of eyes go over your code is a good thing.
Many professors, especially coding professors, tend to say that it’s a good thing to have other people looking over your code to help you catch your errors, 
but in reality it’s not really encouraged in classes. I can understand why, to a degree. No one really wants to see half the class copying from the other half and 
claiming it’s just ‘code reviewing’, but when policies are put in place explicitly telling students not to talk about or collaborate on homeworks or assignments, 
it tends to negate anything the professor may say about leaning on others for help. So having a policy where sharing and looking over each other’s code was encouraged
made the idea more comfortable to me and worked to reinforce the idea that I am working on a team and not as an individual. As for the kanban board,
I think it was helpful in giving me a sense of forward momentum. Even when I was stuck on a single problem and felt like nothing was improving I was able to see all the tasks 
and watch as they progressed during our work time which helped it feel like the project was moving somewhere. 

2. What was most difficult? What would you do differently?

The most difficult part was implementing the kanban board. Up to this point of school any kind of planning like that was entirely up to our discretion and most times,
not having been taught these tools before, most planning was haphazard at best. Trying to break habits of roughly talking through things and then stumbling forward in the 
project was hard. Having to replace those habits with much more organized and structured methods of writing a universal task board with formal assignments then remembering
to advance those assignments as they progressed was even harder. If given a second chance at this, I think I would have utilized the kanban board more, it was treated more 
as an afterthought so we wouldn’t lose points rather than a useful tool for most of the project. I think I would also make more project boards, 
maybe one for each team member so they could further divide their tasks and show their own progress. I know Erick found it useful to break down his larger tasks into 
smaller ones, but since he did it on the overall group board it made it seem a lot more crowded and the work unevenly distributed. Neither really helped with the general 
purpose of the boards. I would also write smaller tasks. Most of the tasks ended up being huge aspects of the project like create music functionality or 
improve CSS design which made them seem a lot more intimidating then they had to be. If we had made them smaller like change button color on homepage or 
create start timer for pomodoro, I think it would have been less scary approaching each task we were in charge of.

3. What software processes or practices might you want to try again in the future on another project?

I would definitely be using the code review in the future, assuming that my future jobs don’t see me as the sole coder/software engineer in the group.
That was really useful for me, as it allowed me to step away from something I’d been focusing on for too long and look at it with fresh eyes, in this case literally. 
I think the kanban boards or something similar to them would also be a technique I’d like to implement more moving forward.


**Overall**
Considering all the design methods, implementation practices, and software processes you've encountered---
compare and contrast how the benefits of the different practices and how they might be useful together

I feel like all the different practices we've learned thoughout the semester bleed into each other and work symbiotically, causing the whole to be worth more than the sum of 
it's parts. For example the effect that design diagrams and prototyping can have on work division and work understanding during implementation. By using things like use 
case diagrams or wireframes developers get a better overall idea of the project and what product they need to see at the end. The diagrams can map out visually various 
interfaces a product might need or specific functionalities that are required to make other parts of the website run smoothly. Or looking at the prototype like a wireframe 
informs the group on the overall look that the product needs to have by the end of the project. These things can flow into implementation in various ways, such as how the tests
are designed and what criteria needs to be passed for the product to be acceptable. Or in process, regarding how the work is broken up and divided on the Kanban board, if the 
use case diagram shows a functionality that no one thought about before hand, that allows it to be create as a task on the boards and assigned 
to someone early on so they have adequate time to work on it rather than everyone rushing to implement the feature after the code fails because it doesn't have that 
vital functionality. This can even work 'backwards', by having processes like kanban boards in place and knowing that all tasks are written down and divided up, other team
members are releived of the stress that comes from not know if some important aspect is being created or not. Each team member is able to focus on their own work during 
implementation as they aren't constantly wondering who is working on X or bothering a teammate because they need to know how Y is progressing. 
Each part tends to support and benefit all the other parts. The process allows everyone to be on the same page with the same understanding of what is done and still needs to
be done. This takes some of the stress away from implemenation and allows team members to focus on thier part of the work. The implmentation itself gives a structure to how 
the project is being built and creates tools to improve the creation of the product. And the design method allows for the project to establish all the information used during
the process part and which will inform what happens in the implemenation as well. 
